import java.util.*;

/*
    G.
    UnionFind.
    Can probly improve the count algo
 */
class MinimizeMalwareSpread {
    private int[] connect;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        connect = new int[graph.length];
        for (int i = 0; i < connect.length; i++) {
            connect[i] = i;
        }
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph[0].length; j++) {
                if (graph[i][j] == 1) union(i, j);
            }
        }

        Map<Integer, Integer> affectedRoot = new HashMap<>();
        for (int i: initial) {
            int root = find(i);
            affectedRoot.put(root, affectedRoot.getOrDefault(root, 0) + 1);
        }

        int max = Integer.MIN_VALUE;
        int maxIndex = Integer.MAX_VALUE;
        int minIndex = initial[0];
        for (int affected: initial) {
            minIndex = Math.min(minIndex, affected);
            if (affectedRoot.get(find(affected)) >= 2) continue;
            int thisMax = count(find(affected));
            if (thisMax == max) {
                maxIndex = Math.min(affected, maxIndex);
            } else if (max < thisMax) {
                max = thisMax;
                maxIndex = affected;
            }
        }

        return maxIndex == Integer.MAX_VALUE ? minIndex : maxIndex;
    }

    private int count(int root) {
        int total = 0;
        boolean[] seen = new boolean[connect.length];
        for (int i = 0; i < connect.length; i++) {
            if (i == root) total++;
            if (seen[i]) continue;
            int jump = i;
            int count = 0;
            while (jump != root && jump != connect[jump]) {
                jump = connect[jump];
                count++;
                seen[jump] = true;
            }
            if (jump == root) total += count;
        }
        return total;
    }

    private void union(int i, int j) {
        int rootI = find(i);
        int rootJ = find(j);
        if (rootI < rootJ) {
            connect[rootJ] = connect[rootI];
        } else if (rootI > rootJ) {
            connect[rootI] = connect[rootJ];
        }
    }

    private int find(int x) {
        if (x == connect[x]) return x;
        return find(connect[x]);
    }
}