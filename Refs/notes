sum 等比数列
3, 6, 12, 24 ....
a1 = 3, q = 2
a1 * (1-pow(q, n))
------------------
     1 - q


sum 等差数列
（首项+末项） * 项数 ÷ 2
(a1 + an) * n
-------------
      2


Buy and Sell Stocks
Q: List of Double nums, means that at time i the stock price is nums[i]
1. 	First we can simply this question, whenever buy or sell, we care about valley and crest, (波峰和波谷)
	so that: [2,5,9,4,1,6,7] -> [2,9,1,7]
2.	if we can only buy and sell one, we need find the map gap
	key is to keep track of MINIMUM BUY and MAX PROFIT.
3.	if can buy/sell multiple times, need to find max profit combinations
	Haven't figure out a good solution, maybe start with biggest gap and with k gaps and compare total profits? like max(sum[0-k], sum[1-k+1] ...).


Quick Selection (Find the Kth smallest element)
Similar to Quick sort, use a pivot and partition the list into 2 part, then only go to one of those. This can reduce time complexity from O(nLogn) to O(n). Worst is still O(n^2).

Suffix Tree:
All suffix of a string is a path in suffix tree. Adjacent chars all compressed together unless it's an end. So all nodes will have two/three children or None.
Use Case: 
	1. find longest repeated substring. (root to farthest INTERNAL node path)
	2. longest palindrome substring

Longest Common Substring:
Can use DP, N*M array, for each i in N compare to j in M, if match, dp[i][j] = dp[i-1][j-1]+1 (previous # of chars matched). For example:
  A B A B
B 0	1 0 1
A 1 0 2 0
B 0 2 0 3
A 1 0 3 0
we have two 3s. So that the end char and length go back.

Boyer-Moore
Bad Char: store last occurance of each char, jump offset to that char when first not match. skip all if not found, shift one if negative. Basically:
s += max(1, j - badchar[txt[s+j]]);
j is matching shifted, badchar returns either -1 when not found, or last seen index

Edge Rank:
1. Affinity Score
2. Edge Weight
3. Time Decay

Consistent Hashing (Partial)
How it works:
Ring that holds N nodes, each nodes responsible for a range.
Hash function transform key to Int, falls into one range and find that node.
	Remove node, if will fall under adjacent node.
	Add new node, will shift data from adjacent node to new node.
Using VNode:
Each physical node can have multiple vnode, which represent a range
	Alleviate hotspot issue (not evenly distributed key)
	
Topological Sorting
Not necessarily has a unique order
For example graph:
5 -> 2 -> 3 -> 1
5 -> 0
4 -> 0
4 -> 1
5,4,2,3,1,0 is one, 4,5,2,3,1,0 is another one.
Similar as DFS, need push all child vertices to a stack then push current node. Also 
need use a hashmap to make sure not re-visit any node.
e.g.
start from 5, push all children to stack: [1,3,2,0]
push 5 itself: [1,3,2,0,5]
next is 4, push all children, 0 and 1 is visited so skip
push 4 itself: [1,3,2,0,5,4]
Also correct if start from 4 then 5.


Binary Min Heap with Array
left(i): 2*i-1 is the index of left child
right(i): 2*i+1 is the index of right child
parent(i): (i-1)/2 is parent index
insert(k): size+=1; arr[size-1]=k; while i>0 and arr[i]<arr[parent(i)]: swap(i, parent(i))
pop(): swap(0, size-1), Heapify Subtree.
Heapify Subtree:
1. if left < parent, swap(left, parent), heapify left subtree
2. if right < parent, swap(right, parent), heapify right subtree


DP: 2D DP, dp[i] ususally means from 0 to i max or min something
    3D DP, dp[i][j] usually means from i to j max or min something.
    Just remember this as some kind of magic formula.


Distributed System Coordination
    - Protocals
        - Paxos: consensus of nodes https://en.wikipedia.org/wiki/Paxos_(computer_science)
        - Gossip: deal with failures https://en.wikipedia.org/wiki/Gossip_protocol

Quick Select
 - find Kth largest/smallest number
 - Quick sort but only partition one side
 - avg O(n), worst O(n^2)

 Binary Indexed Tree
    1. right most 1 bit +1 for update: index += (index & -index)
    2. right most 1 bit -1 for getSum: index -= (index & -index)
 - update +
 - getSum -
 public void updateBIT(int[] BITree, int n, int index, int value) {
    index += 1;
    while (index <= n) {
        BITree[index] += value;
        index += index & -index;
    }
 }

 public int getSum(int[] BITree, int index) {
    index = index + 1;
    int res = 0;
    while (index > 0) {
        res += BITree[index];
        index -= index & -index;
    }
 }

Java negative number:
    1. -1 is all '1' bits
    2. Use 8 bits to represent 32 int bits for example
        2a. -1 is 1111 1111
        2b. -3 is 1111 1101 (-2)
        2c. so -N is -1-(N-1)